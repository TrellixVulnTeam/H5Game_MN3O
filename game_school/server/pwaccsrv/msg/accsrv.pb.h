// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pwngs/protocol/accsrv/accsrv.proto

#ifndef PROTOBUF_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto__INCLUDED
#define PROTOBUF_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto__INCLUDED

#include "pw_iconv.h"
#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "pwngs/options.pb.h"
// @@protoc_insertion_point(includes)

namespace pwngs {
namespace protocol {
namespace accsrv {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();

class CSLoginEx;
class CSLogin;
class SCLoginResult;
class CSTokenLogin;
class SLoginInformation;
class SLoginUserPswd;
class SLogin173;
class SLoginToken;
class SLoginLianYun;
class SLoginTencent;
class SLoginXiYou;
class SLogin360;
class SLoginKor;
class CSLoginNew;

enum EProgramVersion {
  MajorVersion = 1,
  MinorVersion = 0
};
bool EProgramVersion_IsValid(int value);
const EProgramVersion EProgramVersion_MIN = MinorVersion;
const EProgramVersion EProgramVersion_MAX = MajorVersion;
const int EProgramVersion_ARRAYSIZE = EProgramVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* EProgramVersion_descriptor();
inline const ::std::string& EProgramVersion_Name(EProgramVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    EProgramVersion_descriptor(), value);
}
inline bool EProgramVersion_Parse(
    const ::std::string& name, EProgramVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EProgramVersion>(
    EProgramVersion_descriptor(), name, value);
}
enum ELoginType {
  LoginType_UserPswd = 0,
  LoginType_173 = 1,
  LoginType_LaoHu = 2,
  LoginType_LianYun = 3,
  LoginType_Tencent = 4,
  LoginType_ARC = 5,
  LoginType_XiYou = 6,
  LoginType_360 = 7,
  LoginType_Kor = 8,
  LoginType_Ladder = 100
};
bool ELoginType_IsValid(int value);
const ELoginType ELoginType_MIN = LoginType_UserPswd;
const ELoginType ELoginType_MAX = LoginType_Ladder;
const int ELoginType_ARRAYSIZE = ELoginType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ELoginType_descriptor();
inline const ::std::string& ELoginType_Name(ELoginType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ELoginType_descriptor(), value);
}
inline bool ELoginType_Parse(
    const ::std::string& name, ELoginType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ELoginType>(
    ELoginType_descriptor(), name, value);
}
// ===================================================================

class CSLoginEx : public ::google::protobuf::Message {
 public:
  CSLoginEx();
  virtual ~CSLoginEx();
  
  CSLoginEx(const CSLoginEx& from);
  
  inline CSLoginEx& operator=(const CSLoginEx& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CSLoginEx& default_instance();
  
  void Swap(CSLoginEx* other);
  
  // implements Message ----------------------------------------------
  
  CSLoginEx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSLoginEx& from);
  void MergeFrom(const CSLoginEx& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // required int64 tm = 2;
  inline bool has_tm() const;
  inline void clear_tm();
  static const int kTmFieldNumber = 2;
  inline ::google::protobuf::int64 tm() const;
  inline void set_tm(::google::protobuf::int64 value);
  
  // required int32 fatigue = 3;
  inline bool has_fatigue() const;
  inline void clear_fatigue();
  static const int kFatigueFieldNumber = 3;
  inline ::google::protobuf::int32 fatigue() const;
  inline void set_fatigue(::google::protobuf::int32 value);
  
  // required bytes signature = 4;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 4;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void signature_to_mbs();
  inline void signature_to_utf8();
  
  // required int32 major_version = 5;
  inline bool has_major_version() const;
  inline void clear_major_version();
  static const int kMajorVersionFieldNumber = 5;
  inline ::google::protobuf::int32 major_version() const;
  inline void set_major_version(::google::protobuf::int32 value);
  
  // required int32 minor_version = 6;
  inline bool has_minor_version() const;
  inline void clear_minor_version();
  static const int kMinorVersionFieldNumber = 6;
  inline ::google::protobuf::int32 minor_version() const;
  inline void set_minor_version(::google::protobuf::int32 value);
  
  // optional int32 client_type = 7;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 7;
  inline ::google::protobuf::int32 client_type() const;
  inline void set_client_type(::google::protobuf::int32 value);
  
  // optional bytes agent = 8;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 8;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const void* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  inline void agent_to_mbs();
  inline void agent_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.CSLoginEx)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_tm();
  inline void clear_has_tm();
  inline void set_has_fatigue();
  inline void clear_has_fatigue();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_major_version();
  inline void clear_has_major_version();
  inline void set_has_minor_version();
  inline void clear_has_minor_version();
  inline void set_has_client_type();
  inline void clear_has_client_type();
  inline void set_has_agent();
  inline void clear_has_agent();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 userid_;
  ::google::protobuf::int64 tm_;
  ::std::string* signature_;
  ::google::protobuf::int32 fatigue_;
  ::google::protobuf::int32 major_version_;
  ::google::protobuf::int32 minor_version_;
  ::google::protobuf::int32 client_type_;
  ::std::string* agent_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static CSLoginEx* default_instance_;
};
// -------------------------------------------------------------------

class CSLogin : public ::google::protobuf::Message {
 public:
  CSLogin();
  virtual ~CSLogin();
  
  CSLogin(const CSLogin& from);
  
  inline CSLogin& operator=(const CSLogin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CSLogin& default_instance();
  
  void Swap(CSLogin* other);
  
  // implements Message ----------------------------------------------
  
  CSLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSLogin& from);
  void MergeFrom(const CSLogin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void name_to_mbs();
  inline void name_to_utf8();
  
  // required string pswd = 2;
  inline bool has_pswd() const;
  inline void clear_pswd();
  static const int kPswdFieldNumber = 2;
  inline const ::std::string& pswd() const;
  inline void set_pswd(const ::std::string& value);
  inline void set_pswd(const char* value);
  inline void set_pswd(const char* value, size_t size);
  inline ::std::string* mutable_pswd();
  inline ::std::string* release_pswd();
  inline void pswd_to_mbs();
  inline void pswd_to_utf8();
  
  // optional string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void token_to_mbs();
  inline void token_to_utf8();
  
  // required int32 major_version = 4;
  inline bool has_major_version() const;
  inline void clear_major_version();
  static const int kMajorVersionFieldNumber = 4;
  inline ::google::protobuf::int32 major_version() const;
  inline void set_major_version(::google::protobuf::int32 value);
  
  // required int32 minor_version = 5;
  inline bool has_minor_version() const;
  inline void clear_minor_version();
  static const int kMinorVersionFieldNumber = 5;
  inline ::google::protobuf::int32 minor_version() const;
  inline void set_minor_version(::google::protobuf::int32 value);
  
  // optional int32 client_type = 6;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 6;
  inline ::google::protobuf::int32 client_type() const;
  inline void set_client_type(::google::protobuf::int32 value);
  
  // optional bytes agent = 7;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 7;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const void* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  inline void agent_to_mbs();
  inline void agent_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.CSLogin)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pswd();
  inline void clear_has_pswd();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_major_version();
  inline void clear_has_major_version();
  inline void set_has_minor_version();
  inline void clear_has_minor_version();
  inline void set_has_client_type();
  inline void clear_has_client_type();
  inline void set_has_agent();
  inline void clear_has_agent();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* pswd_;
  ::std::string* token_;
  ::google::protobuf::int32 major_version_;
  ::google::protobuf::int32 minor_version_;
  ::std::string* agent_;
  ::google::protobuf::int32 client_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static CSLogin* default_instance_;
};
// -------------------------------------------------------------------

class SCLoginResult : public ::google::protobuf::Message {
 public:
  SCLoginResult();
  virtual ~SCLoginResult();
  
  SCLoginResult(const SCLoginResult& from);
  
  inline SCLoginResult& operator=(const SCLoginResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SCLoginResult& default_instance();
  
  void Swap(SCLoginResult* other);
  
  // implements Message ----------------------------------------------
  
  SCLoginResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCLoginResult& from);
  void MergeFrom(const SCLoginResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void error_to_mbs();
  inline void error_to_utf8();
  
  // optional string suggestion_name = 3;
  inline bool has_suggestion_name() const;
  inline void clear_suggestion_name();
  static const int kSuggestionNameFieldNumber = 3;
  inline const ::std::string& suggestion_name() const;
  inline void set_suggestion_name(const ::std::string& value);
  inline void set_suggestion_name(const char* value);
  inline void set_suggestion_name(const char* value, size_t size);
  inline ::std::string* mutable_suggestion_name();
  inline ::std::string* release_suggestion_name();
  inline void suggestion_name_to_mbs();
  inline void suggestion_name_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.SCLoginResult)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_suggestion_name();
  inline void clear_has_suggestion_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* error_;
  ::std::string* suggestion_name_;
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static SCLoginResult* default_instance_;
};
// -------------------------------------------------------------------

class CSTokenLogin : public ::google::protobuf::Message {
 public:
  CSTokenLogin();
  virtual ~CSTokenLogin();
  
  CSTokenLogin(const CSTokenLogin& from);
  
  inline CSTokenLogin& operator=(const CSTokenLogin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CSTokenLogin& default_instance();
  
  void Swap(CSTokenLogin* other);
  
  // implements Message ----------------------------------------------
  
  CSTokenLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSTokenLogin& from);
  void MergeFrom(const CSTokenLogin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void name_to_mbs();
  inline void name_to_utf8();
  
  // required string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void token_to_mbs();
  inline void token_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.CSTokenLogin)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_token();
  inline void clear_has_token();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* token_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static CSTokenLogin* default_instance_;
};
// -------------------------------------------------------------------

class SLoginInformation : public ::google::protobuf::Message {
 public:
  SLoginInformation();
  virtual ~SLoginInformation();
  
  SLoginInformation(const SLoginInformation& from);
  
  inline SLoginInformation& operator=(const SLoginInformation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLoginInformation& default_instance();
  
  void Swap(SLoginInformation* other);
  
  // implements Message ----------------------------------------------
  
  SLoginInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLoginInformation& from);
  void MergeFrom(const SLoginInformation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 major_version = 1;
  inline bool has_major_version() const;
  inline void clear_major_version();
  static const int kMajorVersionFieldNumber = 1;
  inline ::google::protobuf::int32 major_version() const;
  inline void set_major_version(::google::protobuf::int32 value);
  
  // required int32 minor_version = 2;
  inline bool has_minor_version() const;
  inline void clear_minor_version();
  static const int kMinorVersionFieldNumber = 2;
  inline ::google::protobuf::int32 minor_version() const;
  inline void set_minor_version(::google::protobuf::int32 value);
  
  // optional int32 client_type = 3;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 3;
  inline ::google::protobuf::int32 client_type() const;
  inline void set_client_type(::google::protobuf::int32 value);
  
  // optional bytes agent = 4;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 4;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const void* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  inline void agent_to_mbs();
  inline void agent_to_utf8();
  
  // optional bytes unique_device_id = 5;
  inline bool has_unique_device_id() const;
  inline void clear_unique_device_id();
  static const int kUniqueDeviceIdFieldNumber = 5;
  inline const ::std::string& unique_device_id() const;
  inline void set_unique_device_id(const ::std::string& value);
  inline void set_unique_device_id(const char* value);
  inline void set_unique_device_id(const void* value, size_t size);
  inline ::std::string* mutable_unique_device_id();
  inline ::std::string* release_unique_device_id();
  inline void unique_device_id_to_mbs();
  inline void unique_device_id_to_utf8();
  
  // optional bytes adid = 6;
  inline bool has_adid() const;
  inline void clear_adid();
  static const int kAdidFieldNumber = 6;
  inline const ::std::string& adid() const;
  inline void set_adid(const ::std::string& value);
  inline void set_adid(const char* value);
  inline void set_adid(const void* value, size_t size);
  inline ::std::string* mutable_adid();
  inline ::std::string* release_adid();
  inline void adid_to_mbs();
  inline void adid_to_utf8();
  
  // optional int32 zoneid = 7;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneidFieldNumber = 7;
  inline ::google::protobuf::int32 zoneid() const;
  inline void set_zoneid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.SLoginInformation)
 private:
  inline void set_has_major_version();
  inline void clear_has_major_version();
  inline void set_has_minor_version();
  inline void clear_has_minor_version();
  inline void set_has_client_type();
  inline void clear_has_client_type();
  inline void set_has_agent();
  inline void clear_has_agent();
  inline void set_has_unique_device_id();
  inline void clear_has_unique_device_id();
  inline void set_has_adid();
  inline void clear_has_adid();
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 major_version_;
  ::google::protobuf::int32 minor_version_;
  ::std::string* agent_;
  ::std::string* unique_device_id_;
  ::google::protobuf::int32 client_type_;
  ::google::protobuf::int32 zoneid_;
  ::std::string* adid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static SLoginInformation* default_instance_;
};
// -------------------------------------------------------------------

class SLoginUserPswd : public ::google::protobuf::Message {
 public:
  SLoginUserPswd();
  virtual ~SLoginUserPswd();
  
  SLoginUserPswd(const SLoginUserPswd& from);
  
  inline SLoginUserPswd& operator=(const SLoginUserPswd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLoginUserPswd& default_instance();
  
  void Swap(SLoginUserPswd* other);
  
  // implements Message ----------------------------------------------
  
  SLoginUserPswd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLoginUserPswd& from);
  void MergeFrom(const SLoginUserPswd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void name_to_mbs();
  inline void name_to_utf8();
  
  // required string pswd = 2;
  inline bool has_pswd() const;
  inline void clear_pswd();
  static const int kPswdFieldNumber = 2;
  inline const ::std::string& pswd() const;
  inline void set_pswd(const ::std::string& value);
  inline void set_pswd(const char* value);
  inline void set_pswd(const char* value, size_t size);
  inline ::std::string* mutable_pswd();
  inline ::std::string* release_pswd();
  inline void pswd_to_mbs();
  inline void pswd_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.SLoginUserPswd)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pswd();
  inline void clear_has_pswd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* pswd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static SLoginUserPswd* default_instance_;
};
// -------------------------------------------------------------------

class SLogin173 : public ::google::protobuf::Message {
 public:
  SLogin173();
  virtual ~SLogin173();
  
  SLogin173(const SLogin173& from);
  
  inline SLogin173& operator=(const SLogin173& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLogin173& default_instance();
  
  void Swap(SLogin173* other);
  
  // implements Message ----------------------------------------------
  
  SLogin173* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLogin173& from);
  void MergeFrom(const SLogin173& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // required int64 tm = 2;
  inline bool has_tm() const;
  inline void clear_tm();
  static const int kTmFieldNumber = 2;
  inline ::google::protobuf::int64 tm() const;
  inline void set_tm(::google::protobuf::int64 value);
  
  // required int32 fatigue = 3;
  inline bool has_fatigue() const;
  inline void clear_fatigue();
  static const int kFatigueFieldNumber = 3;
  inline ::google::protobuf::int32 fatigue() const;
  inline void set_fatigue(::google::protobuf::int32 value);
  
  // required bytes signature = 4;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 4;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void signature_to_mbs();
  inline void signature_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.SLogin173)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_tm();
  inline void clear_has_tm();
  inline void set_has_fatigue();
  inline void clear_has_fatigue();
  inline void set_has_signature();
  inline void clear_has_signature();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 userid_;
  ::google::protobuf::int64 tm_;
  ::std::string* signature_;
  ::google::protobuf::int32 fatigue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static SLogin173* default_instance_;
};
// -------------------------------------------------------------------

class SLoginToken : public ::google::protobuf::Message {
 public:
  SLoginToken();
  virtual ~SLoginToken();
  
  SLoginToken(const SLoginToken& from);
  
  inline SLoginToken& operator=(const SLoginToken& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLoginToken& default_instance();
  
  void Swap(SLoginToken* other);
  
  // implements Message ----------------------------------------------
  
  SLoginToken* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLoginToken& from);
  void MergeFrom(const SLoginToken& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void name_to_mbs();
  inline void name_to_utf8();
  
  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void token_to_mbs();
  inline void token_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.SLoginToken)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_token();
  inline void clear_has_token();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* token_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static SLoginToken* default_instance_;
};
// -------------------------------------------------------------------

class SLoginLianYun : public ::google::protobuf::Message {
 public:
  SLoginLianYun();
  virtual ~SLoginLianYun();
  
  SLoginLianYun(const SLoginLianYun& from);
  
  inline SLoginLianYun& operator=(const SLoginLianYun& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLoginLianYun& default_instance();
  
  void Swap(SLoginLianYun* other);
  
  // implements Message ----------------------------------------------
  
  SLoginLianYun* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLoginLianYun& from);
  void MergeFrom(const SLoginLianYun& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void ip_to_mbs();
  inline void ip_to_utf8();
  
  // optional int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // optional int32 serverid = 3;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 3;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);
  
  // optional bytes servername = 4;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 4;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const void* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void servername_to_mbs();
  inline void servername_to_utf8();
  
  // optional bytes agent = 5;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 5;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const void* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  inline void agent_to_mbs();
  inline void agent_to_utf8();
  
  // optional bytes uid = 6;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 6;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const void* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void uid_to_mbs();
  inline void uid_to_utf8();
  
  // optional int64 t = 7;
  inline bool has_t() const;
  inline void clear_t();
  static const int kTFieldNumber = 7;
  inline ::google::protobuf::int64 t() const;
  inline void set_t(::google::protobuf::int64 value);
  
  // optional int32 cm = 8;
  inline bool has_cm() const;
  inline void clear_cm();
  static const int kCmFieldNumber = 8;
  inline ::google::protobuf::int32 cm() const;
  inline void set_cm(::google::protobuf::int32 value);
  
  // optional bytes sign = 9;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 9;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const void* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void sign_to_mbs();
  inline void sign_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.SLoginLianYun)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_agent();
  inline void clear_has_agent();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_t();
  inline void clear_has_t();
  inline void set_has_cm();
  inline void clear_has_cm();
  inline void set_has_sign();
  inline void clear_has_sign();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 serverid_;
  ::std::string* servername_;
  ::std::string* agent_;
  ::std::string* uid_;
  ::google::protobuf::int64 t_;
  ::std::string* sign_;
  ::google::protobuf::int32 cm_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static SLoginLianYun* default_instance_;
};
// -------------------------------------------------------------------

class SLoginTencent : public ::google::protobuf::Message {
 public:
  SLoginTencent();
  virtual ~SLoginTencent();
  
  SLoginTencent(const SLoginTencent& from);
  
  inline SLoginTencent& operator=(const SLoginTencent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLoginTencent& default_instance();
  
  void Swap(SLoginTencent* other);
  
  // implements Message ----------------------------------------------
  
  SLoginTencent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLoginTencent& from);
  void MergeFrom(const SLoginTencent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string openid = 1;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 1;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void openid_to_mbs();
  inline void openid_to_utf8();
  
  // required string openkey = 2;
  inline bool has_openkey() const;
  inline void clear_openkey();
  static const int kOpenkeyFieldNumber = 2;
  inline const ::std::string& openkey() const;
  inline void set_openkey(const ::std::string& value);
  inline void set_openkey(const char* value);
  inline void set_openkey(const char* value, size_t size);
  inline ::std::string* mutable_openkey();
  inline ::std::string* release_openkey();
  inline void openkey_to_mbs();
  inline void openkey_to_utf8();
  
  // required string platform = 3;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 3;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void platform_to_mbs();
  inline void platform_to_utf8();
  
  // required string platform_key = 4;
  inline bool has_platform_key() const;
  inline void clear_platform_key();
  static const int kPlatformKeyFieldNumber = 4;
  inline const ::std::string& platform_key() const;
  inline void set_platform_key(const ::std::string& value);
  inline void set_platform_key(const char* value);
  inline void set_platform_key(const char* value, size_t size);
  inline ::std::string* mutable_platform_key();
  inline ::std::string* release_platform_key();
  inline void platform_key_to_mbs();
  inline void platform_key_to_utf8();
  
  // optional int32 pid = 5;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 5;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.SLoginTencent)
 private:
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_openkey();
  inline void clear_has_openkey();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_platform_key();
  inline void clear_has_platform_key();
  inline void set_has_pid();
  inline void clear_has_pid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* openid_;
  ::std::string* openkey_;
  ::std::string* platform_;
  ::std::string* platform_key_;
  ::google::protobuf::int32 pid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static SLoginTencent* default_instance_;
};
// -------------------------------------------------------------------

class SLoginXiYou : public ::google::protobuf::Message {
 public:
  SLoginXiYou();
  virtual ~SLoginXiYou();
  
  SLoginXiYou(const SLoginXiYou& from);
  
  inline SLoginXiYou& operator=(const SLoginXiYou& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLoginXiYou& default_instance();
  
  void Swap(SLoginXiYou* other);
  
  // implements Message ----------------------------------------------
  
  SLoginXiYou* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLoginXiYou& from);
  void MergeFrom(const SLoginXiYou& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void sid_to_mbs();
  inline void sid_to_utf8();
  
  // required string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void uid_to_mbs();
  inline void uid_to_utf8();
  
  // required int32 fcm = 3;
  inline bool has_fcm() const;
  inline void clear_fcm();
  static const int kFcmFieldNumber = 3;
  inline ::google::protobuf::int32 fcm() const;
  inline void set_fcm(::google::protobuf::int32 value);
  
  // required string exts = 4;
  inline bool has_exts() const;
  inline void clear_exts();
  static const int kExtsFieldNumber = 4;
  inline const ::std::string& exts() const;
  inline void set_exts(const ::std::string& value);
  inline void set_exts(const char* value);
  inline void set_exts(const char* value, size_t size);
  inline ::std::string* mutable_exts();
  inline ::std::string* release_exts();
  inline void exts_to_mbs();
  inline void exts_to_utf8();
  
  // required int64 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // required string platform = 6;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 6;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void platform_to_mbs();
  inline void platform_to_utf8();
  
  // required string sign = 7;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 7;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void sign_to_mbs();
  inline void sign_to_utf8();
  
  // required string type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void type_to_mbs();
  inline void type_to_utf8();
  
  // required string channel = 9;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 9;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void channel_to_mbs();
  inline void channel_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.SLoginXiYou)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_fcm();
  inline void clear_has_fcm();
  inline void set_has_exts();
  inline void clear_has_exts();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_channel();
  inline void clear_has_channel();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sid_;
  ::std::string* uid_;
  ::std::string* exts_;
  ::google::protobuf::int64 time_;
  ::std::string* platform_;
  ::std::string* sign_;
  ::std::string* type_;
  ::std::string* channel_;
  ::google::protobuf::int32 fcm_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static SLoginXiYou* default_instance_;
};
// -------------------------------------------------------------------

class SLogin360 : public ::google::protobuf::Message {
 public:
  SLogin360();
  virtual ~SLogin360();
  
  SLogin360(const SLogin360& from);
  
  inline SLogin360& operator=(const SLogin360& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLogin360& default_instance();
  
  void Swap(SLogin360* other);
  
  // implements Message ----------------------------------------------
  
  SLogin360* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLogin360& from);
  void MergeFrom(const SLogin360& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 qid = 1;
  inline bool has_qid() const;
  inline void clear_qid();
  static const int kQidFieldNumber = 1;
  inline ::google::protobuf::int64 qid() const;
  inline void set_qid(::google::protobuf::int64 value);
  
  // required string server_id = 2;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 2;
  inline const ::std::string& server_id() const;
  inline void set_server_id(const ::std::string& value);
  inline void set_server_id(const char* value);
  inline void set_server_id(const char* value, size_t size);
  inline ::std::string* mutable_server_id();
  inline ::std::string* release_server_id();
  inline void server_id_to_mbs();
  inline void server_id_to_utf8();
  
  // required int64 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // required int32 isAdult = 4;
  inline bool has_isadult() const;
  inline void clear_isadult();
  static const int kIsAdultFieldNumber = 4;
  inline ::google::protobuf::int32 isadult() const;
  inline void set_isadult(::google::protobuf::int32 value);
  
  // required string sign = 5;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 5;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void sign_to_mbs();
  inline void sign_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.SLogin360)
 private:
  inline void set_has_qid();
  inline void clear_has_qid();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_isadult();
  inline void clear_has_isadult();
  inline void set_has_sign();
  inline void clear_has_sign();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 qid_;
  ::std::string* server_id_;
  ::google::protobuf::int64 time_;
  ::std::string* sign_;
  ::google::protobuf::int32 isadult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static SLogin360* default_instance_;
};
// -------------------------------------------------------------------

class SLoginKor : public ::google::protobuf::Message {
 public:
  SLoginKor();
  virtual ~SLoginKor();
  
  SLoginKor(const SLoginKor& from);
  
  inline SLoginKor& operator=(const SLoginKor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SLoginKor& default_instance();
  
  void Swap(SLoginKor* other);
  
  // implements Message ----------------------------------------------
  
  SLoginKor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLoginKor& from);
  void MergeFrom(const SLoginKor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);
  
  // required string platform = 2;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 2;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void platform_to_mbs();
  inline void platform_to_utf8();
  
  // required int32 sid = 3;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 3;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);
  
  // required int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // required int32 fcm = 5;
  inline bool has_fcm() const;
  inline void clear_fcm();
  static const int kFcmFieldNumber = 5;
  inline ::google::protobuf::int32 fcm() const;
  inline void set_fcm(::google::protobuf::int32 value);
  
  // required int32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string sign = 7;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 7;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void sign_to_mbs();
  inline void sign_to_utf8();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.SLoginKor)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_fcm();
  inline void clear_has_fcm();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sign();
  inline void clear_has_sign();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 uid_;
  ::std::string* platform_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 sid_;
  ::google::protobuf::int32 fcm_;
  ::std::string* sign_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static SLoginKor* default_instance_;
};
// -------------------------------------------------------------------

class CSLoginNew : public ::google::protobuf::Message {
 public:
  CSLoginNew();
  virtual ~CSLoginNew();
  
  CSLoginNew(const CSLoginNew& from);
  
  inline CSLoginNew& operator=(const CSLoginNew& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CSLoginNew& default_instance();
  
  void Swap(CSLoginNew* other);
  
  // implements Message ----------------------------------------------
  
  CSLoginNew* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSLoginNew& from);
  void MergeFrom(const CSLoginNew& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pwngs.protocol.accsrv.ELoginType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline pwngs::protocol::accsrv::ELoginType type() const;
  inline void set_type(pwngs::protocol::accsrv::ELoginType value);
  
  // optional .pwngs.protocol.accsrv.SLoginInformation loginInfo = 2;
  inline bool has_logininfo() const;
  inline void clear_logininfo();
  static const int kLoginInfoFieldNumber = 2;
  inline const ::pwngs::protocol::accsrv::SLoginInformation& logininfo() const;
  inline ::pwngs::protocol::accsrv::SLoginInformation* mutable_logininfo();
  inline ::pwngs::protocol::accsrv::SLoginInformation* release_logininfo();
  
  // optional .pwngs.protocol.accsrv.SLoginUserPswd loginUserPswd = 3;
  inline bool has_loginuserpswd() const;
  inline void clear_loginuserpswd();
  static const int kLoginUserPswdFieldNumber = 3;
  inline const ::pwngs::protocol::accsrv::SLoginUserPswd& loginuserpswd() const;
  inline ::pwngs::protocol::accsrv::SLoginUserPswd* mutable_loginuserpswd();
  inline ::pwngs::protocol::accsrv::SLoginUserPswd* release_loginuserpswd();
  
  // optional .pwngs.protocol.accsrv.SLogin173 login173 = 4;
  inline bool has_login173() const;
  inline void clear_login173();
  static const int kLogin173FieldNumber = 4;
  inline const ::pwngs::protocol::accsrv::SLogin173& login173() const;
  inline ::pwngs::protocol::accsrv::SLogin173* mutable_login173();
  inline ::pwngs::protocol::accsrv::SLogin173* release_login173();
  
  // optional .pwngs.protocol.accsrv.SLoginToken loginToken = 5;
  inline bool has_logintoken() const;
  inline void clear_logintoken();
  static const int kLoginTokenFieldNumber = 5;
  inline const ::pwngs::protocol::accsrv::SLoginToken& logintoken() const;
  inline ::pwngs::protocol::accsrv::SLoginToken* mutable_logintoken();
  inline ::pwngs::protocol::accsrv::SLoginToken* release_logintoken();
  
  // optional .pwngs.protocol.accsrv.SLoginLianYun loginLianYun = 6;
  inline bool has_loginlianyun() const;
  inline void clear_loginlianyun();
  static const int kLoginLianYunFieldNumber = 6;
  inline const ::pwngs::protocol::accsrv::SLoginLianYun& loginlianyun() const;
  inline ::pwngs::protocol::accsrv::SLoginLianYun* mutable_loginlianyun();
  inline ::pwngs::protocol::accsrv::SLoginLianYun* release_loginlianyun();
  
  // optional .pwngs.protocol.accsrv.SLoginTencent loginTencent = 7;
  inline bool has_logintencent() const;
  inline void clear_logintencent();
  static const int kLoginTencentFieldNumber = 7;
  inline const ::pwngs::protocol::accsrv::SLoginTencent& logintencent() const;
  inline ::pwngs::protocol::accsrv::SLoginTencent* mutable_logintencent();
  inline ::pwngs::protocol::accsrv::SLoginTencent* release_logintencent();
  
  // optional .pwngs.protocol.accsrv.SLoginXiYou loginXiYou = 8;
  inline bool has_loginxiyou() const;
  inline void clear_loginxiyou();
  static const int kLoginXiYouFieldNumber = 8;
  inline const ::pwngs::protocol::accsrv::SLoginXiYou& loginxiyou() const;
  inline ::pwngs::protocol::accsrv::SLoginXiYou* mutable_loginxiyou();
  inline ::pwngs::protocol::accsrv::SLoginXiYou* release_loginxiyou();
  
  // optional .pwngs.protocol.accsrv.SLogin360 login360 = 9;
  inline bool has_login360() const;
  inline void clear_login360();
  static const int kLogin360FieldNumber = 9;
  inline const ::pwngs::protocol::accsrv::SLogin360& login360() const;
  inline ::pwngs::protocol::accsrv::SLogin360* mutable_login360();
  inline ::pwngs::protocol::accsrv::SLogin360* release_login360();
  
  // optional .pwngs.protocol.accsrv.SLoginKor loginKor = 10;
  inline bool has_loginkor() const;
  inline void clear_loginkor();
  static const int kLoginKorFieldNumber = 10;
  inline const ::pwngs::protocol::accsrv::SLoginKor& loginkor() const;
  inline ::pwngs::protocol::accsrv::SLoginKor* mutable_loginkor();
  inline ::pwngs::protocol::accsrv::SLoginKor* release_loginkor();
  
  // @@protoc_insertion_point(class_scope:pwngs.protocol.accsrv.CSLoginNew)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_logininfo();
  inline void clear_has_logininfo();
  inline void set_has_loginuserpswd();
  inline void clear_has_loginuserpswd();
  inline void set_has_login173();
  inline void clear_has_login173();
  inline void set_has_logintoken();
  inline void clear_has_logintoken();
  inline void set_has_loginlianyun();
  inline void clear_has_loginlianyun();
  inline void set_has_logintencent();
  inline void clear_has_logintencent();
  inline void set_has_loginxiyou();
  inline void clear_has_loginxiyou();
  inline void set_has_login360();
  inline void clear_has_login360();
  inline void set_has_loginkor();
  inline void clear_has_loginkor();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pwngs::protocol::accsrv::SLoginInformation* logininfo_;
  ::pwngs::protocol::accsrv::SLoginUserPswd* loginuserpswd_;
  ::pwngs::protocol::accsrv::SLogin173* login173_;
  ::pwngs::protocol::accsrv::SLoginToken* logintoken_;
  ::pwngs::protocol::accsrv::SLoginLianYun* loginlianyun_;
  ::pwngs::protocol::accsrv::SLoginTencent* logintencent_;
  ::pwngs::protocol::accsrv::SLoginXiYou* loginxiyou_;
  ::pwngs::protocol::accsrv::SLogin360* login360_;
  ::pwngs::protocol::accsrv::SLoginKor* loginkor_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_AssignDesc_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  friend void protobuf_ShutdownFile_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto();
  
  void InitAsDefaultInstance();
  static CSLoginNew* default_instance_;
};
// ===================================================================


// ===================================================================

// CSLoginEx

// required int64 userid = 1;
inline bool CSLoginEx::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLoginEx::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLoginEx::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLoginEx::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 CSLoginEx::userid() const {
  return userid_;
}
inline void CSLoginEx::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// required int64 tm = 2;
inline bool CSLoginEx::has_tm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSLoginEx::set_has_tm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSLoginEx::clear_has_tm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSLoginEx::clear_tm() {
  tm_ = GOOGLE_LONGLONG(0);
  clear_has_tm();
}
inline ::google::protobuf::int64 CSLoginEx::tm() const {
  return tm_;
}
inline void CSLoginEx::set_tm(::google::protobuf::int64 value) {
  set_has_tm();
  tm_ = value;
}

// required int32 fatigue = 3;
inline bool CSLoginEx::has_fatigue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSLoginEx::set_has_fatigue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSLoginEx::clear_has_fatigue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSLoginEx::clear_fatigue() {
  fatigue_ = 0;
  clear_has_fatigue();
}
inline ::google::protobuf::int32 CSLoginEx::fatigue() const {
  return fatigue_;
}
inline void CSLoginEx::set_fatigue(::google::protobuf::int32 value) {
  set_has_fatigue();
  fatigue_ = value;
}

// required bytes signature = 4;
inline bool CSLoginEx::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSLoginEx::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSLoginEx::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSLoginEx::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline void CSLoginEx::signature_to_mbs() {
*signature_ = pwutils::utf8_to_mbs(*signature_);
}
inline void CSLoginEx::signature_to_utf8() {
*signature_ = pwutils::utf8_from_mbs(*signature_);
}
inline const ::std::string& CSLoginEx::signature() const {
  return *signature_;
}
inline void CSLoginEx::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void CSLoginEx::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void CSLoginEx::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginEx::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* CSLoginEx::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 major_version = 5;
inline bool CSLoginEx::has_major_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSLoginEx::set_has_major_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSLoginEx::clear_has_major_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSLoginEx::clear_major_version() {
  major_version_ = 0;
  clear_has_major_version();
}
inline ::google::protobuf::int32 CSLoginEx::major_version() const {
  return major_version_;
}
inline void CSLoginEx::set_major_version(::google::protobuf::int32 value) {
  set_has_major_version();
  major_version_ = value;
}

// required int32 minor_version = 6;
inline bool CSLoginEx::has_minor_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSLoginEx::set_has_minor_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSLoginEx::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSLoginEx::clear_minor_version() {
  minor_version_ = 0;
  clear_has_minor_version();
}
inline ::google::protobuf::int32 CSLoginEx::minor_version() const {
  return minor_version_;
}
inline void CSLoginEx::set_minor_version(::google::protobuf::int32 value) {
  set_has_minor_version();
  minor_version_ = value;
}

// optional int32 client_type = 7;
inline bool CSLoginEx::has_client_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSLoginEx::set_has_client_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSLoginEx::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSLoginEx::clear_client_type() {
  client_type_ = 0;
  clear_has_client_type();
}
inline ::google::protobuf::int32 CSLoginEx::client_type() const {
  return client_type_;
}
inline void CSLoginEx::set_client_type(::google::protobuf::int32 value) {
  set_has_client_type();
  client_type_ = value;
}

// optional bytes agent = 8;
inline bool CSLoginEx::has_agent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSLoginEx::set_has_agent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSLoginEx::clear_has_agent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSLoginEx::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline void CSLoginEx::agent_to_mbs() {
*agent_ = pwutils::utf8_to_mbs(*agent_);
}
inline void CSLoginEx::agent_to_utf8() {
*agent_ = pwutils::utf8_from_mbs(*agent_);
}
inline const ::std::string& CSLoginEx::agent() const {
  return *agent_;
}
inline void CSLoginEx::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void CSLoginEx::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void CSLoginEx::set_agent(const void* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginEx::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* CSLoginEx::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CSLogin

// required string name = 1;
inline bool CSLogin::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLogin::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLogin::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLogin::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline void CSLogin::name_to_mbs() {
*name_ = pwutils::utf8_to_mbs(*name_);
}
inline void CSLogin::name_to_utf8() {
*name_ = pwutils::utf8_from_mbs(*name_);
}
inline const ::std::string& CSLogin::name() const {
  return *name_;
}
inline void CSLogin::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSLogin::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSLogin::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLogin::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSLogin::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string pswd = 2;
inline bool CSLogin::has_pswd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSLogin::set_has_pswd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSLogin::clear_has_pswd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSLogin::clear_pswd() {
  if (pswd_ != &::google::protobuf::internal::kEmptyString) {
    pswd_->clear();
  }
  clear_has_pswd();
}
inline void CSLogin::pswd_to_mbs() {
*pswd_ = pwutils::utf8_to_mbs(*pswd_);
}
inline void CSLogin::pswd_to_utf8() {
*pswd_ = pwutils::utf8_from_mbs(*pswd_);
}
inline const ::std::string& CSLogin::pswd() const {
  return *pswd_;
}
inline void CSLogin::set_pswd(const ::std::string& value) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(value);
}
inline void CSLogin::set_pswd(const char* value) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(value);
}
inline void CSLogin::set_pswd(const char* value, size_t size) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLogin::mutable_pswd() {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  return pswd_;
}
inline ::std::string* CSLogin::release_pswd() {
  clear_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pswd_;
    pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string token = 3;
inline bool CSLogin::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSLogin::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSLogin::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSLogin::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline void CSLogin::token_to_mbs() {
*token_ = pwutils::utf8_to_mbs(*token_);
}
inline void CSLogin::token_to_utf8() {
*token_ = pwutils::utf8_from_mbs(*token_);
}
inline const ::std::string& CSLogin::token() const {
  return *token_;
}
inline void CSLogin::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSLogin::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSLogin::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLogin::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CSLogin::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 major_version = 4;
inline bool CSLogin::has_major_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSLogin::set_has_major_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSLogin::clear_has_major_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSLogin::clear_major_version() {
  major_version_ = 0;
  clear_has_major_version();
}
inline ::google::protobuf::int32 CSLogin::major_version() const {
  return major_version_;
}
inline void CSLogin::set_major_version(::google::protobuf::int32 value) {
  set_has_major_version();
  major_version_ = value;
}

// required int32 minor_version = 5;
inline bool CSLogin::has_minor_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSLogin::set_has_minor_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSLogin::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSLogin::clear_minor_version() {
  minor_version_ = 0;
  clear_has_minor_version();
}
inline ::google::protobuf::int32 CSLogin::minor_version() const {
  return minor_version_;
}
inline void CSLogin::set_minor_version(::google::protobuf::int32 value) {
  set_has_minor_version();
  minor_version_ = value;
}

// optional int32 client_type = 6;
inline bool CSLogin::has_client_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSLogin::set_has_client_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSLogin::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSLogin::clear_client_type() {
  client_type_ = 0;
  clear_has_client_type();
}
inline ::google::protobuf::int32 CSLogin::client_type() const {
  return client_type_;
}
inline void CSLogin::set_client_type(::google::protobuf::int32 value) {
  set_has_client_type();
  client_type_ = value;
}

// optional bytes agent = 7;
inline bool CSLogin::has_agent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSLogin::set_has_agent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSLogin::clear_has_agent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSLogin::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline void CSLogin::agent_to_mbs() {
*agent_ = pwutils::utf8_to_mbs(*agent_);
}
inline void CSLogin::agent_to_utf8() {
*agent_ = pwutils::utf8_from_mbs(*agent_);
}
inline const ::std::string& CSLogin::agent() const {
  return *agent_;
}
inline void CSLogin::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void CSLogin::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void CSLogin::set_agent(const void* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLogin::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* CSLogin::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SCLoginResult

// required int32 result = 1;
inline bool SCLoginResult::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SCLoginResult::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SCLoginResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SCLoginResult::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 SCLoginResult::result() const {
  return result_;
}
inline void SCLoginResult::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string error = 2;
inline bool SCLoginResult::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SCLoginResult::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SCLoginResult::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SCLoginResult::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline void SCLoginResult::error_to_mbs() {
*error_ = pwutils::utf8_to_mbs(*error_);
}
inline void SCLoginResult::error_to_utf8() {
*error_ = pwutils::utf8_from_mbs(*error_);
}
inline const ::std::string& SCLoginResult::error() const {
  return *error_;
}
inline void SCLoginResult::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void SCLoginResult::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void SCLoginResult::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SCLoginResult::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* SCLoginResult::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string suggestion_name = 3;
inline bool SCLoginResult::has_suggestion_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SCLoginResult::set_has_suggestion_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SCLoginResult::clear_has_suggestion_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SCLoginResult::clear_suggestion_name() {
  if (suggestion_name_ != &::google::protobuf::internal::kEmptyString) {
    suggestion_name_->clear();
  }
  clear_has_suggestion_name();
}
inline void SCLoginResult::suggestion_name_to_mbs() {
*suggestion_name_ = pwutils::utf8_to_mbs(*suggestion_name_);
}
inline void SCLoginResult::suggestion_name_to_utf8() {
*suggestion_name_ = pwutils::utf8_from_mbs(*suggestion_name_);
}
inline const ::std::string& SCLoginResult::suggestion_name() const {
  return *suggestion_name_;
}
inline void SCLoginResult::set_suggestion_name(const ::std::string& value) {
  set_has_suggestion_name();
  if (suggestion_name_ == &::google::protobuf::internal::kEmptyString) {
    suggestion_name_ = new ::std::string;
  }
  suggestion_name_->assign(value);
}
inline void SCLoginResult::set_suggestion_name(const char* value) {
  set_has_suggestion_name();
  if (suggestion_name_ == &::google::protobuf::internal::kEmptyString) {
    suggestion_name_ = new ::std::string;
  }
  suggestion_name_->assign(value);
}
inline void SCLoginResult::set_suggestion_name(const char* value, size_t size) {
  set_has_suggestion_name();
  if (suggestion_name_ == &::google::protobuf::internal::kEmptyString) {
    suggestion_name_ = new ::std::string;
  }
  suggestion_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SCLoginResult::mutable_suggestion_name() {
  set_has_suggestion_name();
  if (suggestion_name_ == &::google::protobuf::internal::kEmptyString) {
    suggestion_name_ = new ::std::string;
  }
  return suggestion_name_;
}
inline ::std::string* SCLoginResult::release_suggestion_name() {
  clear_has_suggestion_name();
  if (suggestion_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suggestion_name_;
    suggestion_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CSTokenLogin

// required int32 type = 1;
inline bool CSTokenLogin::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSTokenLogin::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSTokenLogin::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSTokenLogin::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CSTokenLogin::type() const {
  return type_;
}
inline void CSTokenLogin::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string name = 2;
inline bool CSTokenLogin::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSTokenLogin::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSTokenLogin::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSTokenLogin::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline void CSTokenLogin::name_to_mbs() {
*name_ = pwutils::utf8_to_mbs(*name_);
}
inline void CSTokenLogin::name_to_utf8() {
*name_ = pwutils::utf8_from_mbs(*name_);
}
inline const ::std::string& CSTokenLogin::name() const {
  return *name_;
}
inline void CSTokenLogin::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSTokenLogin::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSTokenLogin::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSTokenLogin::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSTokenLogin::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string token = 3;
inline bool CSTokenLogin::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSTokenLogin::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSTokenLogin::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSTokenLogin::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline void CSTokenLogin::token_to_mbs() {
*token_ = pwutils::utf8_to_mbs(*token_);
}
inline void CSTokenLogin::token_to_utf8() {
*token_ = pwutils::utf8_from_mbs(*token_);
}
inline const ::std::string& CSTokenLogin::token() const {
  return *token_;
}
inline void CSTokenLogin::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSTokenLogin::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSTokenLogin::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSTokenLogin::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CSTokenLogin::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SLoginInformation

// required int32 major_version = 1;
inline bool SLoginInformation::has_major_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLoginInformation::set_has_major_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLoginInformation::clear_has_major_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLoginInformation::clear_major_version() {
  major_version_ = 0;
  clear_has_major_version();
}
inline ::google::protobuf::int32 SLoginInformation::major_version() const {
  return major_version_;
}
inline void SLoginInformation::set_major_version(::google::protobuf::int32 value) {
  set_has_major_version();
  major_version_ = value;
}

// required int32 minor_version = 2;
inline bool SLoginInformation::has_minor_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLoginInformation::set_has_minor_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLoginInformation::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLoginInformation::clear_minor_version() {
  minor_version_ = 0;
  clear_has_minor_version();
}
inline ::google::protobuf::int32 SLoginInformation::minor_version() const {
  return minor_version_;
}
inline void SLoginInformation::set_minor_version(::google::protobuf::int32 value) {
  set_has_minor_version();
  minor_version_ = value;
}

// optional int32 client_type = 3;
inline bool SLoginInformation::has_client_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SLoginInformation::set_has_client_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SLoginInformation::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SLoginInformation::clear_client_type() {
  client_type_ = 0;
  clear_has_client_type();
}
inline ::google::protobuf::int32 SLoginInformation::client_type() const {
  return client_type_;
}
inline void SLoginInformation::set_client_type(::google::protobuf::int32 value) {
  set_has_client_type();
  client_type_ = value;
}

// optional bytes agent = 4;
inline bool SLoginInformation::has_agent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SLoginInformation::set_has_agent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SLoginInformation::clear_has_agent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SLoginInformation::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline void SLoginInformation::agent_to_mbs() {
*agent_ = pwutils::utf8_to_mbs(*agent_);
}
inline void SLoginInformation::agent_to_utf8() {
*agent_ = pwutils::utf8_from_mbs(*agent_);
}
inline const ::std::string& SLoginInformation::agent() const {
  return *agent_;
}
inline void SLoginInformation::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void SLoginInformation::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void SLoginInformation::set_agent(const void* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginInformation::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* SLoginInformation::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes unique_device_id = 5;
inline bool SLoginInformation::has_unique_device_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SLoginInformation::set_has_unique_device_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SLoginInformation::clear_has_unique_device_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SLoginInformation::clear_unique_device_id() {
  if (unique_device_id_ != &::google::protobuf::internal::kEmptyString) {
    unique_device_id_->clear();
  }
  clear_has_unique_device_id();
}
inline void SLoginInformation::unique_device_id_to_mbs() {
*unique_device_id_ = pwutils::utf8_to_mbs(*unique_device_id_);
}
inline void SLoginInformation::unique_device_id_to_utf8() {
*unique_device_id_ = pwutils::utf8_from_mbs(*unique_device_id_);
}
inline const ::std::string& SLoginInformation::unique_device_id() const {
  return *unique_device_id_;
}
inline void SLoginInformation::set_unique_device_id(const ::std::string& value) {
  set_has_unique_device_id();
  if (unique_device_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_device_id_ = new ::std::string;
  }
  unique_device_id_->assign(value);
}
inline void SLoginInformation::set_unique_device_id(const char* value) {
  set_has_unique_device_id();
  if (unique_device_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_device_id_ = new ::std::string;
  }
  unique_device_id_->assign(value);
}
inline void SLoginInformation::set_unique_device_id(const void* value, size_t size) {
  set_has_unique_device_id();
  if (unique_device_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_device_id_ = new ::std::string;
  }
  unique_device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginInformation::mutable_unique_device_id() {
  set_has_unique_device_id();
  if (unique_device_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_device_id_ = new ::std::string;
  }
  return unique_device_id_;
}
inline ::std::string* SLoginInformation::release_unique_device_id() {
  clear_has_unique_device_id();
  if (unique_device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unique_device_id_;
    unique_device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes adid = 6;
inline bool SLoginInformation::has_adid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SLoginInformation::set_has_adid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SLoginInformation::clear_has_adid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SLoginInformation::clear_adid() {
  if (adid_ != &::google::protobuf::internal::kEmptyString) {
    adid_->clear();
  }
  clear_has_adid();
}
inline void SLoginInformation::adid_to_mbs() {
*adid_ = pwutils::utf8_to_mbs(*adid_);
}
inline void SLoginInformation::adid_to_utf8() {
*adid_ = pwutils::utf8_from_mbs(*adid_);
}
inline const ::std::string& SLoginInformation::adid() const {
  return *adid_;
}
inline void SLoginInformation::set_adid(const ::std::string& value) {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::kEmptyString) {
    adid_ = new ::std::string;
  }
  adid_->assign(value);
}
inline void SLoginInformation::set_adid(const char* value) {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::kEmptyString) {
    adid_ = new ::std::string;
  }
  adid_->assign(value);
}
inline void SLoginInformation::set_adid(const void* value, size_t size) {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::kEmptyString) {
    adid_ = new ::std::string;
  }
  adid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginInformation::mutable_adid() {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::kEmptyString) {
    adid_ = new ::std::string;
  }
  return adid_;
}
inline ::std::string* SLoginInformation::release_adid() {
  clear_has_adid();
  if (adid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = adid_;
    adid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 zoneid = 7;
inline bool SLoginInformation::has_zoneid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SLoginInformation::set_has_zoneid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SLoginInformation::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SLoginInformation::clear_zoneid() {
  zoneid_ = 0;
  clear_has_zoneid();
}
inline ::google::protobuf::int32 SLoginInformation::zoneid() const {
  return zoneid_;
}
inline void SLoginInformation::set_zoneid(::google::protobuf::int32 value) {
  set_has_zoneid();
  zoneid_ = value;
}

// -------------------------------------------------------------------

// SLoginUserPswd

// required string name = 1;
inline bool SLoginUserPswd::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLoginUserPswd::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLoginUserPswd::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLoginUserPswd::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline void SLoginUserPswd::name_to_mbs() {
*name_ = pwutils::utf8_to_mbs(*name_);
}
inline void SLoginUserPswd::name_to_utf8() {
*name_ = pwutils::utf8_from_mbs(*name_);
}
inline const ::std::string& SLoginUserPswd::name() const {
  return *name_;
}
inline void SLoginUserPswd::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SLoginUserPswd::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SLoginUserPswd::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginUserPswd::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SLoginUserPswd::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string pswd = 2;
inline bool SLoginUserPswd::has_pswd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLoginUserPswd::set_has_pswd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLoginUserPswd::clear_has_pswd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLoginUserPswd::clear_pswd() {
  if (pswd_ != &::google::protobuf::internal::kEmptyString) {
    pswd_->clear();
  }
  clear_has_pswd();
}
inline void SLoginUserPswd::pswd_to_mbs() {
*pswd_ = pwutils::utf8_to_mbs(*pswd_);
}
inline void SLoginUserPswd::pswd_to_utf8() {
*pswd_ = pwutils::utf8_from_mbs(*pswd_);
}
inline const ::std::string& SLoginUserPswd::pswd() const {
  return *pswd_;
}
inline void SLoginUserPswd::set_pswd(const ::std::string& value) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(value);
}
inline void SLoginUserPswd::set_pswd(const char* value) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(value);
}
inline void SLoginUserPswd::set_pswd(const char* value, size_t size) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginUserPswd::mutable_pswd() {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  return pswd_;
}
inline ::std::string* SLoginUserPswd::release_pswd() {
  clear_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pswd_;
    pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SLogin173

// required int64 userid = 1;
inline bool SLogin173::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLogin173::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLogin173::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLogin173::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 SLogin173::userid() const {
  return userid_;
}
inline void SLogin173::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// required int64 tm = 2;
inline bool SLogin173::has_tm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLogin173::set_has_tm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLogin173::clear_has_tm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLogin173::clear_tm() {
  tm_ = GOOGLE_LONGLONG(0);
  clear_has_tm();
}
inline ::google::protobuf::int64 SLogin173::tm() const {
  return tm_;
}
inline void SLogin173::set_tm(::google::protobuf::int64 value) {
  set_has_tm();
  tm_ = value;
}

// required int32 fatigue = 3;
inline bool SLogin173::has_fatigue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SLogin173::set_has_fatigue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SLogin173::clear_has_fatigue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SLogin173::clear_fatigue() {
  fatigue_ = 0;
  clear_has_fatigue();
}
inline ::google::protobuf::int32 SLogin173::fatigue() const {
  return fatigue_;
}
inline void SLogin173::set_fatigue(::google::protobuf::int32 value) {
  set_has_fatigue();
  fatigue_ = value;
}

// required bytes signature = 4;
inline bool SLogin173::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SLogin173::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SLogin173::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SLogin173::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline void SLogin173::signature_to_mbs() {
*signature_ = pwutils::utf8_to_mbs(*signature_);
}
inline void SLogin173::signature_to_utf8() {
*signature_ = pwutils::utf8_from_mbs(*signature_);
}
inline const ::std::string& SLogin173::signature() const {
  return *signature_;
}
inline void SLogin173::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SLogin173::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SLogin173::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLogin173::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SLogin173::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SLoginToken

// required string name = 1;
inline bool SLoginToken::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLoginToken::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLoginToken::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLoginToken::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline void SLoginToken::name_to_mbs() {
*name_ = pwutils::utf8_to_mbs(*name_);
}
inline void SLoginToken::name_to_utf8() {
*name_ = pwutils::utf8_from_mbs(*name_);
}
inline const ::std::string& SLoginToken::name() const {
  return *name_;
}
inline void SLoginToken::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SLoginToken::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SLoginToken::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginToken::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SLoginToken::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string token = 2;
inline bool SLoginToken::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLoginToken::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLoginToken::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLoginToken::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline void SLoginToken::token_to_mbs() {
*token_ = pwutils::utf8_to_mbs(*token_);
}
inline void SLoginToken::token_to_utf8() {
*token_ = pwutils::utf8_from_mbs(*token_);
}
inline const ::std::string& SLoginToken::token() const {
  return *token_;
}
inline void SLoginToken::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void SLoginToken::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void SLoginToken::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginToken::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* SLoginToken::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SLoginLianYun

// optional bytes ip = 1;
inline bool SLoginLianYun::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLoginLianYun::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLoginLianYun::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLoginLianYun::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline void SLoginLianYun::ip_to_mbs() {
*ip_ = pwutils::utf8_to_mbs(*ip_);
}
inline void SLoginLianYun::ip_to_utf8() {
*ip_ = pwutils::utf8_from_mbs(*ip_);
}
inline const ::std::string& SLoginLianYun::ip() const {
  return *ip_;
}
inline void SLoginLianYun::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void SLoginLianYun::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void SLoginLianYun::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginLianYun::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* SLoginLianYun::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 port = 2;
inline bool SLoginLianYun::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLoginLianYun::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLoginLianYun::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLoginLianYun::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 SLoginLianYun::port() const {
  return port_;
}
inline void SLoginLianYun::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional int32 serverid = 3;
inline bool SLoginLianYun::has_serverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SLoginLianYun::set_has_serverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SLoginLianYun::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SLoginLianYun::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 SLoginLianYun::serverid() const {
  return serverid_;
}
inline void SLoginLianYun::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional bytes servername = 4;
inline bool SLoginLianYun::has_servername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SLoginLianYun::set_has_servername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SLoginLianYun::clear_has_servername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SLoginLianYun::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline void SLoginLianYun::servername_to_mbs() {
*servername_ = pwutils::utf8_to_mbs(*servername_);
}
inline void SLoginLianYun::servername_to_utf8() {
*servername_ = pwutils::utf8_from_mbs(*servername_);
}
inline const ::std::string& SLoginLianYun::servername() const {
  return *servername_;
}
inline void SLoginLianYun::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void SLoginLianYun::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void SLoginLianYun::set_servername(const void* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginLianYun::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* SLoginLianYun::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes agent = 5;
inline bool SLoginLianYun::has_agent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SLoginLianYun::set_has_agent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SLoginLianYun::clear_has_agent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SLoginLianYun::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline void SLoginLianYun::agent_to_mbs() {
*agent_ = pwutils::utf8_to_mbs(*agent_);
}
inline void SLoginLianYun::agent_to_utf8() {
*agent_ = pwutils::utf8_from_mbs(*agent_);
}
inline const ::std::string& SLoginLianYun::agent() const {
  return *agent_;
}
inline void SLoginLianYun::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void SLoginLianYun::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void SLoginLianYun::set_agent(const void* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginLianYun::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* SLoginLianYun::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes uid = 6;
inline bool SLoginLianYun::has_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SLoginLianYun::set_has_uid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SLoginLianYun::clear_has_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SLoginLianYun::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline void SLoginLianYun::uid_to_mbs() {
*uid_ = pwutils::utf8_to_mbs(*uid_);
}
inline void SLoginLianYun::uid_to_utf8() {
*uid_ = pwutils::utf8_from_mbs(*uid_);
}
inline const ::std::string& SLoginLianYun::uid() const {
  return *uid_;
}
inline void SLoginLianYun::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SLoginLianYun::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SLoginLianYun::set_uid(const void* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginLianYun::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SLoginLianYun::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 t = 7;
inline bool SLoginLianYun::has_t() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SLoginLianYun::set_has_t() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SLoginLianYun::clear_has_t() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SLoginLianYun::clear_t() {
  t_ = GOOGLE_LONGLONG(0);
  clear_has_t();
}
inline ::google::protobuf::int64 SLoginLianYun::t() const {
  return t_;
}
inline void SLoginLianYun::set_t(::google::protobuf::int64 value) {
  set_has_t();
  t_ = value;
}

// optional int32 cm = 8;
inline bool SLoginLianYun::has_cm() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SLoginLianYun::set_has_cm() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SLoginLianYun::clear_has_cm() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SLoginLianYun::clear_cm() {
  cm_ = 0;
  clear_has_cm();
}
inline ::google::protobuf::int32 SLoginLianYun::cm() const {
  return cm_;
}
inline void SLoginLianYun::set_cm(::google::protobuf::int32 value) {
  set_has_cm();
  cm_ = value;
}

// optional bytes sign = 9;
inline bool SLoginLianYun::has_sign() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SLoginLianYun::set_has_sign() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SLoginLianYun::clear_has_sign() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SLoginLianYun::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline void SLoginLianYun::sign_to_mbs() {
*sign_ = pwutils::utf8_to_mbs(*sign_);
}
inline void SLoginLianYun::sign_to_utf8() {
*sign_ = pwutils::utf8_from_mbs(*sign_);
}
inline const ::std::string& SLoginLianYun::sign() const {
  return *sign_;
}
inline void SLoginLianYun::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void SLoginLianYun::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void SLoginLianYun::set_sign(const void* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginLianYun::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* SLoginLianYun::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SLoginTencent

// required string openid = 1;
inline bool SLoginTencent::has_openid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLoginTencent::set_has_openid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLoginTencent::clear_has_openid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLoginTencent::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline void SLoginTencent::openid_to_mbs() {
*openid_ = pwutils::utf8_to_mbs(*openid_);
}
inline void SLoginTencent::openid_to_utf8() {
*openid_ = pwutils::utf8_from_mbs(*openid_);
}
inline const ::std::string& SLoginTencent::openid() const {
  return *openid_;
}
inline void SLoginTencent::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void SLoginTencent::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void SLoginTencent::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginTencent::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* SLoginTencent::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string openkey = 2;
inline bool SLoginTencent::has_openkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLoginTencent::set_has_openkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLoginTencent::clear_has_openkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLoginTencent::clear_openkey() {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    openkey_->clear();
  }
  clear_has_openkey();
}
inline void SLoginTencent::openkey_to_mbs() {
*openkey_ = pwutils::utf8_to_mbs(*openkey_);
}
inline void SLoginTencent::openkey_to_utf8() {
*openkey_ = pwutils::utf8_from_mbs(*openkey_);
}
inline const ::std::string& SLoginTencent::openkey() const {
  return *openkey_;
}
inline void SLoginTencent::set_openkey(const ::std::string& value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void SLoginTencent::set_openkey(const char* value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void SLoginTencent::set_openkey(const char* value, size_t size) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginTencent::mutable_openkey() {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  return openkey_;
}
inline ::std::string* SLoginTencent::release_openkey() {
  clear_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openkey_;
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string platform = 3;
inline bool SLoginTencent::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SLoginTencent::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SLoginTencent::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SLoginTencent::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline void SLoginTencent::platform_to_mbs() {
*platform_ = pwutils::utf8_to_mbs(*platform_);
}
inline void SLoginTencent::platform_to_utf8() {
*platform_ = pwutils::utf8_from_mbs(*platform_);
}
inline const ::std::string& SLoginTencent::platform() const {
  return *platform_;
}
inline void SLoginTencent::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void SLoginTencent::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void SLoginTencent::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginTencent::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* SLoginTencent::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string platform_key = 4;
inline bool SLoginTencent::has_platform_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SLoginTencent::set_has_platform_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SLoginTencent::clear_has_platform_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SLoginTencent::clear_platform_key() {
  if (platform_key_ != &::google::protobuf::internal::kEmptyString) {
    platform_key_->clear();
  }
  clear_has_platform_key();
}
inline void SLoginTencent::platform_key_to_mbs() {
*platform_key_ = pwutils::utf8_to_mbs(*platform_key_);
}
inline void SLoginTencent::platform_key_to_utf8() {
*platform_key_ = pwutils::utf8_from_mbs(*platform_key_);
}
inline const ::std::string& SLoginTencent::platform_key() const {
  return *platform_key_;
}
inline void SLoginTencent::set_platform_key(const ::std::string& value) {
  set_has_platform_key();
  if (platform_key_ == &::google::protobuf::internal::kEmptyString) {
    platform_key_ = new ::std::string;
  }
  platform_key_->assign(value);
}
inline void SLoginTencent::set_platform_key(const char* value) {
  set_has_platform_key();
  if (platform_key_ == &::google::protobuf::internal::kEmptyString) {
    platform_key_ = new ::std::string;
  }
  platform_key_->assign(value);
}
inline void SLoginTencent::set_platform_key(const char* value, size_t size) {
  set_has_platform_key();
  if (platform_key_ == &::google::protobuf::internal::kEmptyString) {
    platform_key_ = new ::std::string;
  }
  platform_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginTencent::mutable_platform_key() {
  set_has_platform_key();
  if (platform_key_ == &::google::protobuf::internal::kEmptyString) {
    platform_key_ = new ::std::string;
  }
  return platform_key_;
}
inline ::std::string* SLoginTencent::release_platform_key() {
  clear_has_platform_key();
  if (platform_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_key_;
    platform_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 pid = 5;
inline bool SLoginTencent::has_pid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SLoginTencent::set_has_pid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SLoginTencent::clear_has_pid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SLoginTencent::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 SLoginTencent::pid() const {
  return pid_;
}
inline void SLoginTencent::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// -------------------------------------------------------------------

// SLoginXiYou

// required string sid = 1;
inline bool SLoginXiYou::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLoginXiYou::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLoginXiYou::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLoginXiYou::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline void SLoginXiYou::sid_to_mbs() {
*sid_ = pwutils::utf8_to_mbs(*sid_);
}
inline void SLoginXiYou::sid_to_utf8() {
*sid_ = pwutils::utf8_from_mbs(*sid_);
}
inline const ::std::string& SLoginXiYou::sid() const {
  return *sid_;
}
inline void SLoginXiYou::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void SLoginXiYou::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void SLoginXiYou::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginXiYou::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* SLoginXiYou::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string uid = 2;
inline bool SLoginXiYou::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLoginXiYou::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLoginXiYou::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLoginXiYou::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline void SLoginXiYou::uid_to_mbs() {
*uid_ = pwutils::utf8_to_mbs(*uid_);
}
inline void SLoginXiYou::uid_to_utf8() {
*uid_ = pwutils::utf8_from_mbs(*uid_);
}
inline const ::std::string& SLoginXiYou::uid() const {
  return *uid_;
}
inline void SLoginXiYou::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SLoginXiYou::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SLoginXiYou::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginXiYou::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SLoginXiYou::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 fcm = 3;
inline bool SLoginXiYou::has_fcm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SLoginXiYou::set_has_fcm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SLoginXiYou::clear_has_fcm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SLoginXiYou::clear_fcm() {
  fcm_ = 0;
  clear_has_fcm();
}
inline ::google::protobuf::int32 SLoginXiYou::fcm() const {
  return fcm_;
}
inline void SLoginXiYou::set_fcm(::google::protobuf::int32 value) {
  set_has_fcm();
  fcm_ = value;
}

// required string exts = 4;
inline bool SLoginXiYou::has_exts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SLoginXiYou::set_has_exts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SLoginXiYou::clear_has_exts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SLoginXiYou::clear_exts() {
  if (exts_ != &::google::protobuf::internal::kEmptyString) {
    exts_->clear();
  }
  clear_has_exts();
}
inline void SLoginXiYou::exts_to_mbs() {
*exts_ = pwutils::utf8_to_mbs(*exts_);
}
inline void SLoginXiYou::exts_to_utf8() {
*exts_ = pwutils::utf8_from_mbs(*exts_);
}
inline const ::std::string& SLoginXiYou::exts() const {
  return *exts_;
}
inline void SLoginXiYou::set_exts(const ::std::string& value) {
  set_has_exts();
  if (exts_ == &::google::protobuf::internal::kEmptyString) {
    exts_ = new ::std::string;
  }
  exts_->assign(value);
}
inline void SLoginXiYou::set_exts(const char* value) {
  set_has_exts();
  if (exts_ == &::google::protobuf::internal::kEmptyString) {
    exts_ = new ::std::string;
  }
  exts_->assign(value);
}
inline void SLoginXiYou::set_exts(const char* value, size_t size) {
  set_has_exts();
  if (exts_ == &::google::protobuf::internal::kEmptyString) {
    exts_ = new ::std::string;
  }
  exts_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginXiYou::mutable_exts() {
  set_has_exts();
  if (exts_ == &::google::protobuf::internal::kEmptyString) {
    exts_ = new ::std::string;
  }
  return exts_;
}
inline ::std::string* SLoginXiYou::release_exts() {
  clear_has_exts();
  if (exts_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exts_;
    exts_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 time = 5;
inline bool SLoginXiYou::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SLoginXiYou::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SLoginXiYou::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SLoginXiYou::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 SLoginXiYou::time() const {
  return time_;
}
inline void SLoginXiYou::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required string platform = 6;
inline bool SLoginXiYou::has_platform() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SLoginXiYou::set_has_platform() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SLoginXiYou::clear_has_platform() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SLoginXiYou::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline void SLoginXiYou::platform_to_mbs() {
*platform_ = pwutils::utf8_to_mbs(*platform_);
}
inline void SLoginXiYou::platform_to_utf8() {
*platform_ = pwutils::utf8_from_mbs(*platform_);
}
inline const ::std::string& SLoginXiYou::platform() const {
  return *platform_;
}
inline void SLoginXiYou::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void SLoginXiYou::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void SLoginXiYou::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginXiYou::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* SLoginXiYou::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string sign = 7;
inline bool SLoginXiYou::has_sign() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SLoginXiYou::set_has_sign() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SLoginXiYou::clear_has_sign() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SLoginXiYou::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline void SLoginXiYou::sign_to_mbs() {
*sign_ = pwutils::utf8_to_mbs(*sign_);
}
inline void SLoginXiYou::sign_to_utf8() {
*sign_ = pwutils::utf8_from_mbs(*sign_);
}
inline const ::std::string& SLoginXiYou::sign() const {
  return *sign_;
}
inline void SLoginXiYou::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void SLoginXiYou::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void SLoginXiYou::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginXiYou::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* SLoginXiYou::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string type = 8;
inline bool SLoginXiYou::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SLoginXiYou::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SLoginXiYou::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SLoginXiYou::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline void SLoginXiYou::type_to_mbs() {
*type_ = pwutils::utf8_to_mbs(*type_);
}
inline void SLoginXiYou::type_to_utf8() {
*type_ = pwutils::utf8_from_mbs(*type_);
}
inline const ::std::string& SLoginXiYou::type() const {
  return *type_;
}
inline void SLoginXiYou::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SLoginXiYou::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SLoginXiYou::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginXiYou::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* SLoginXiYou::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string channel = 9;
inline bool SLoginXiYou::has_channel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SLoginXiYou::set_has_channel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SLoginXiYou::clear_has_channel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SLoginXiYou::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline void SLoginXiYou::channel_to_mbs() {
*channel_ = pwutils::utf8_to_mbs(*channel_);
}
inline void SLoginXiYou::channel_to_utf8() {
*channel_ = pwutils::utf8_from_mbs(*channel_);
}
inline const ::std::string& SLoginXiYou::channel() const {
  return *channel_;
}
inline void SLoginXiYou::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void SLoginXiYou::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void SLoginXiYou::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginXiYou::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* SLoginXiYou::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SLogin360

// required int64 qid = 1;
inline bool SLogin360::has_qid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLogin360::set_has_qid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLogin360::clear_has_qid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLogin360::clear_qid() {
  qid_ = GOOGLE_LONGLONG(0);
  clear_has_qid();
}
inline ::google::protobuf::int64 SLogin360::qid() const {
  return qid_;
}
inline void SLogin360::set_qid(::google::protobuf::int64 value) {
  set_has_qid();
  qid_ = value;
}

// required string server_id = 2;
inline bool SLogin360::has_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLogin360::set_has_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLogin360::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLogin360::clear_server_id() {
  if (server_id_ != &::google::protobuf::internal::kEmptyString) {
    server_id_->clear();
  }
  clear_has_server_id();
}
inline void SLogin360::server_id_to_mbs() {
*server_id_ = pwutils::utf8_to_mbs(*server_id_);
}
inline void SLogin360::server_id_to_utf8() {
*server_id_ = pwutils::utf8_from_mbs(*server_id_);
}
inline const ::std::string& SLogin360::server_id() const {
  return *server_id_;
}
inline void SLogin360::set_server_id(const ::std::string& value) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(value);
}
inline void SLogin360::set_server_id(const char* value) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(value);
}
inline void SLogin360::set_server_id(const char* value, size_t size) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLogin360::mutable_server_id() {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  return server_id_;
}
inline ::std::string* SLogin360::release_server_id() {
  clear_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_id_;
    server_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 time = 3;
inline bool SLogin360::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SLogin360::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SLogin360::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SLogin360::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 SLogin360::time() const {
  return time_;
}
inline void SLogin360::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required int32 isAdult = 4;
inline bool SLogin360::has_isadult() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SLogin360::set_has_isadult() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SLogin360::clear_has_isadult() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SLogin360::clear_isadult() {
  isadult_ = 0;
  clear_has_isadult();
}
inline ::google::protobuf::int32 SLogin360::isadult() const {
  return isadult_;
}
inline void SLogin360::set_isadult(::google::protobuf::int32 value) {
  set_has_isadult();
  isadult_ = value;
}

// required string sign = 5;
inline bool SLogin360::has_sign() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SLogin360::set_has_sign() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SLogin360::clear_has_sign() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SLogin360::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline void SLogin360::sign_to_mbs() {
*sign_ = pwutils::utf8_to_mbs(*sign_);
}
inline void SLogin360::sign_to_utf8() {
*sign_ = pwutils::utf8_from_mbs(*sign_);
}
inline const ::std::string& SLogin360::sign() const {
  return *sign_;
}
inline void SLogin360::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void SLogin360::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void SLogin360::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLogin360::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* SLogin360::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SLoginKor

// required int64 uid = 1;
inline bool SLoginKor::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLoginKor::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLoginKor::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLoginKor::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 SLoginKor::uid() const {
  return uid_;
}
inline void SLoginKor::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// required string platform = 2;
inline bool SLoginKor::has_platform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLoginKor::set_has_platform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLoginKor::clear_has_platform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLoginKor::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline void SLoginKor::platform_to_mbs() {
*platform_ = pwutils::utf8_to_mbs(*platform_);
}
inline void SLoginKor::platform_to_utf8() {
*platform_ = pwutils::utf8_from_mbs(*platform_);
}
inline const ::std::string& SLoginKor::platform() const {
  return *platform_;
}
inline void SLoginKor::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void SLoginKor::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void SLoginKor::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginKor::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* SLoginKor::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 sid = 3;
inline bool SLoginKor::has_sid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SLoginKor::set_has_sid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SLoginKor::clear_has_sid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SLoginKor::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 SLoginKor::sid() const {
  return sid_;
}
inline void SLoginKor::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
}

// required int64 time = 4;
inline bool SLoginKor::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SLoginKor::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SLoginKor::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SLoginKor::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 SLoginKor::time() const {
  return time_;
}
inline void SLoginKor::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required int32 fcm = 5;
inline bool SLoginKor::has_fcm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SLoginKor::set_has_fcm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SLoginKor::clear_has_fcm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SLoginKor::clear_fcm() {
  fcm_ = 0;
  clear_has_fcm();
}
inline ::google::protobuf::int32 SLoginKor::fcm() const {
  return fcm_;
}
inline void SLoginKor::set_fcm(::google::protobuf::int32 value) {
  set_has_fcm();
  fcm_ = value;
}

// required int32 type = 6;
inline bool SLoginKor::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SLoginKor::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SLoginKor::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SLoginKor::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SLoginKor::type() const {
  return type_;
}
inline void SLoginKor::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string sign = 7;
inline bool SLoginKor::has_sign() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SLoginKor::set_has_sign() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SLoginKor::clear_has_sign() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SLoginKor::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline void SLoginKor::sign_to_mbs() {
*sign_ = pwutils::utf8_to_mbs(*sign_);
}
inline void SLoginKor::sign_to_utf8() {
*sign_ = pwutils::utf8_from_mbs(*sign_);
}
inline const ::std::string& SLoginKor::sign() const {
  return *sign_;
}
inline void SLoginKor::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void SLoginKor::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void SLoginKor::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLoginKor::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* SLoginKor::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CSLoginNew

// required .pwngs.protocol.accsrv.ELoginType type = 1;
inline bool CSLoginNew::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLoginNew::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLoginNew::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLoginNew::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline pwngs::protocol::accsrv::ELoginType CSLoginNew::type() const {
  return static_cast< pwngs::protocol::accsrv::ELoginType >(type_);
}
inline void CSLoginNew::set_type(pwngs::protocol::accsrv::ELoginType value) {
  GOOGLE_DCHECK(pwngs::protocol::accsrv::ELoginType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .pwngs.protocol.accsrv.SLoginInformation loginInfo = 2;
inline bool CSLoginNew::has_logininfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSLoginNew::set_has_logininfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSLoginNew::clear_has_logininfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSLoginNew::clear_logininfo() {
  if (logininfo_ != NULL) logininfo_->::pwngs::protocol::accsrv::SLoginInformation::Clear();
  clear_has_logininfo();
}
inline const ::pwngs::protocol::accsrv::SLoginInformation& CSLoginNew::logininfo() const {
  return logininfo_ != NULL ? *logininfo_ : *default_instance_->logininfo_;
}
inline ::pwngs::protocol::accsrv::SLoginInformation* CSLoginNew::mutable_logininfo() {
  set_has_logininfo();
  if (logininfo_ == NULL) logininfo_ = new ::pwngs::protocol::accsrv::SLoginInformation;
  return logininfo_;
}
inline ::pwngs::protocol::accsrv::SLoginInformation* CSLoginNew::release_logininfo() {
  clear_has_logininfo();
  ::pwngs::protocol::accsrv::SLoginInformation* temp = logininfo_;
  logininfo_ = NULL;
  return temp;
}

// optional .pwngs.protocol.accsrv.SLoginUserPswd loginUserPswd = 3;
inline bool CSLoginNew::has_loginuserpswd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSLoginNew::set_has_loginuserpswd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSLoginNew::clear_has_loginuserpswd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSLoginNew::clear_loginuserpswd() {
  if (loginuserpswd_ != NULL) loginuserpswd_->::pwngs::protocol::accsrv::SLoginUserPswd::Clear();
  clear_has_loginuserpswd();
}
inline const ::pwngs::protocol::accsrv::SLoginUserPswd& CSLoginNew::loginuserpswd() const {
  return loginuserpswd_ != NULL ? *loginuserpswd_ : *default_instance_->loginuserpswd_;
}
inline ::pwngs::protocol::accsrv::SLoginUserPswd* CSLoginNew::mutable_loginuserpswd() {
  set_has_loginuserpswd();
  if (loginuserpswd_ == NULL) loginuserpswd_ = new ::pwngs::protocol::accsrv::SLoginUserPswd;
  return loginuserpswd_;
}
inline ::pwngs::protocol::accsrv::SLoginUserPswd* CSLoginNew::release_loginuserpswd() {
  clear_has_loginuserpswd();
  ::pwngs::protocol::accsrv::SLoginUserPswd* temp = loginuserpswd_;
  loginuserpswd_ = NULL;
  return temp;
}

// optional .pwngs.protocol.accsrv.SLogin173 login173 = 4;
inline bool CSLoginNew::has_login173() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSLoginNew::set_has_login173() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSLoginNew::clear_has_login173() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSLoginNew::clear_login173() {
  if (login173_ != NULL) login173_->::pwngs::protocol::accsrv::SLogin173::Clear();
  clear_has_login173();
}
inline const ::pwngs::protocol::accsrv::SLogin173& CSLoginNew::login173() const {
  return login173_ != NULL ? *login173_ : *default_instance_->login173_;
}
inline ::pwngs::protocol::accsrv::SLogin173* CSLoginNew::mutable_login173() {
  set_has_login173();
  if (login173_ == NULL) login173_ = new ::pwngs::protocol::accsrv::SLogin173;
  return login173_;
}
inline ::pwngs::protocol::accsrv::SLogin173* CSLoginNew::release_login173() {
  clear_has_login173();
  ::pwngs::protocol::accsrv::SLogin173* temp = login173_;
  login173_ = NULL;
  return temp;
}

// optional .pwngs.protocol.accsrv.SLoginToken loginToken = 5;
inline bool CSLoginNew::has_logintoken() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSLoginNew::set_has_logintoken() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSLoginNew::clear_has_logintoken() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSLoginNew::clear_logintoken() {
  if (logintoken_ != NULL) logintoken_->::pwngs::protocol::accsrv::SLoginToken::Clear();
  clear_has_logintoken();
}
inline const ::pwngs::protocol::accsrv::SLoginToken& CSLoginNew::logintoken() const {
  return logintoken_ != NULL ? *logintoken_ : *default_instance_->logintoken_;
}
inline ::pwngs::protocol::accsrv::SLoginToken* CSLoginNew::mutable_logintoken() {
  set_has_logintoken();
  if (logintoken_ == NULL) logintoken_ = new ::pwngs::protocol::accsrv::SLoginToken;
  return logintoken_;
}
inline ::pwngs::protocol::accsrv::SLoginToken* CSLoginNew::release_logintoken() {
  clear_has_logintoken();
  ::pwngs::protocol::accsrv::SLoginToken* temp = logintoken_;
  logintoken_ = NULL;
  return temp;
}

// optional .pwngs.protocol.accsrv.SLoginLianYun loginLianYun = 6;
inline bool CSLoginNew::has_loginlianyun() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSLoginNew::set_has_loginlianyun() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSLoginNew::clear_has_loginlianyun() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSLoginNew::clear_loginlianyun() {
  if (loginlianyun_ != NULL) loginlianyun_->::pwngs::protocol::accsrv::SLoginLianYun::Clear();
  clear_has_loginlianyun();
}
inline const ::pwngs::protocol::accsrv::SLoginLianYun& CSLoginNew::loginlianyun() const {
  return loginlianyun_ != NULL ? *loginlianyun_ : *default_instance_->loginlianyun_;
}
inline ::pwngs::protocol::accsrv::SLoginLianYun* CSLoginNew::mutable_loginlianyun() {
  set_has_loginlianyun();
  if (loginlianyun_ == NULL) loginlianyun_ = new ::pwngs::protocol::accsrv::SLoginLianYun;
  return loginlianyun_;
}
inline ::pwngs::protocol::accsrv::SLoginLianYun* CSLoginNew::release_loginlianyun() {
  clear_has_loginlianyun();
  ::pwngs::protocol::accsrv::SLoginLianYun* temp = loginlianyun_;
  loginlianyun_ = NULL;
  return temp;
}

// optional .pwngs.protocol.accsrv.SLoginTencent loginTencent = 7;
inline bool CSLoginNew::has_logintencent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSLoginNew::set_has_logintencent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSLoginNew::clear_has_logintencent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSLoginNew::clear_logintencent() {
  if (logintencent_ != NULL) logintencent_->::pwngs::protocol::accsrv::SLoginTencent::Clear();
  clear_has_logintencent();
}
inline const ::pwngs::protocol::accsrv::SLoginTencent& CSLoginNew::logintencent() const {
  return logintencent_ != NULL ? *logintencent_ : *default_instance_->logintencent_;
}
inline ::pwngs::protocol::accsrv::SLoginTencent* CSLoginNew::mutable_logintencent() {
  set_has_logintencent();
  if (logintencent_ == NULL) logintencent_ = new ::pwngs::protocol::accsrv::SLoginTencent;
  return logintencent_;
}
inline ::pwngs::protocol::accsrv::SLoginTencent* CSLoginNew::release_logintencent() {
  clear_has_logintencent();
  ::pwngs::protocol::accsrv::SLoginTencent* temp = logintencent_;
  logintencent_ = NULL;
  return temp;
}

// optional .pwngs.protocol.accsrv.SLoginXiYou loginXiYou = 8;
inline bool CSLoginNew::has_loginxiyou() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSLoginNew::set_has_loginxiyou() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSLoginNew::clear_has_loginxiyou() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSLoginNew::clear_loginxiyou() {
  if (loginxiyou_ != NULL) loginxiyou_->::pwngs::protocol::accsrv::SLoginXiYou::Clear();
  clear_has_loginxiyou();
}
inline const ::pwngs::protocol::accsrv::SLoginXiYou& CSLoginNew::loginxiyou() const {
  return loginxiyou_ != NULL ? *loginxiyou_ : *default_instance_->loginxiyou_;
}
inline ::pwngs::protocol::accsrv::SLoginXiYou* CSLoginNew::mutable_loginxiyou() {
  set_has_loginxiyou();
  if (loginxiyou_ == NULL) loginxiyou_ = new ::pwngs::protocol::accsrv::SLoginXiYou;
  return loginxiyou_;
}
inline ::pwngs::protocol::accsrv::SLoginXiYou* CSLoginNew::release_loginxiyou() {
  clear_has_loginxiyou();
  ::pwngs::protocol::accsrv::SLoginXiYou* temp = loginxiyou_;
  loginxiyou_ = NULL;
  return temp;
}

// optional .pwngs.protocol.accsrv.SLogin360 login360 = 9;
inline bool CSLoginNew::has_login360() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSLoginNew::set_has_login360() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSLoginNew::clear_has_login360() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSLoginNew::clear_login360() {
  if (login360_ != NULL) login360_->::pwngs::protocol::accsrv::SLogin360::Clear();
  clear_has_login360();
}
inline const ::pwngs::protocol::accsrv::SLogin360& CSLoginNew::login360() const {
  return login360_ != NULL ? *login360_ : *default_instance_->login360_;
}
inline ::pwngs::protocol::accsrv::SLogin360* CSLoginNew::mutable_login360() {
  set_has_login360();
  if (login360_ == NULL) login360_ = new ::pwngs::protocol::accsrv::SLogin360;
  return login360_;
}
inline ::pwngs::protocol::accsrv::SLogin360* CSLoginNew::release_login360() {
  clear_has_login360();
  ::pwngs::protocol::accsrv::SLogin360* temp = login360_;
  login360_ = NULL;
  return temp;
}

// optional .pwngs.protocol.accsrv.SLoginKor loginKor = 10;
inline bool CSLoginNew::has_loginkor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSLoginNew::set_has_loginkor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSLoginNew::clear_has_loginkor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSLoginNew::clear_loginkor() {
  if (loginkor_ != NULL) loginkor_->::pwngs::protocol::accsrv::SLoginKor::Clear();
  clear_has_loginkor();
}
inline const ::pwngs::protocol::accsrv::SLoginKor& CSLoginNew::loginkor() const {
  return loginkor_ != NULL ? *loginkor_ : *default_instance_->loginkor_;
}
inline ::pwngs::protocol::accsrv::SLoginKor* CSLoginNew::mutable_loginkor() {
  set_has_loginkor();
  if (loginkor_ == NULL) loginkor_ = new ::pwngs::protocol::accsrv::SLoginKor;
  return loginkor_;
}
inline ::pwngs::protocol::accsrv::SLoginKor* CSLoginNew::release_loginkor() {
  clear_has_loginkor();
  ::pwngs::protocol::accsrv::SLoginKor* temp = loginkor_;
  loginkor_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace accsrv
}  // namespace protocol
}  // namespace pwngs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< pwngs::protocol::accsrv::EProgramVersion>() {
  return pwngs::protocol::accsrv::EProgramVersion_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< pwngs::protocol::accsrv::ELoginType>() {
  return pwngs::protocol::accsrv::ELoginType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pwngs_2fprotocol_2faccsrv_2faccsrv_2eproto__INCLUDED
